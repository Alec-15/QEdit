The editor for Quest 6 uses Electron Forge and React. Electron Forge allows us a built a stand-alone app, rather than a web page, but using the same code. React gives us a framework for an interface that is responsive (the user makes a change and the UI instantly updates everything it should).

React uses a principle called "single source of truth", which means the data is held in a single place, and every UI component refers to that to determine what it should be showing. In this app, this is in a dictionary call "state" in the top component, App, in app.js. Whenever the user makes a change in a component, that change has to be passed up to App, which then calls setState with a new dictionary with the updated values. Reach then sorts out what needs to be updated in the UI.

The UI is split between:

The side pane on the left, with the hierarchy of objects, handled in sidepane.js

The main pane on the right, with the tabbed details of each object, handled in mainpane.js.

# Setting up

To kick-start the project I did this (from [here](https://github.com/electron-userland/electron-forge-templates)):

```
npm install -g electron-forge
electron-forge init my-project --template=react
```

Presumably React can be installed without the template, but otherwise just delete everything in the src directory, and replace it with this. You can then start the app like this:

```
electron-forge start
```




# React Overview

### JSX

React uses JSX, which is a mix of JavaScript and XHTML (that is, XML-compliant HTML). This means that you can put HTML right into the JavaScript code, like this:

```
    return (  
      <tr className="form-group">
        <td><span className="fieldName">{props.display}</span></td>
        <td><select
          className="form-control"
          id={props.name}
          name={props.name}
          value={props.value}
          title={props.input.tooltip}
          onChange={props.handleChange}
        >
        {options.map((s, i) => <option value={s} key={i}>{s}</option>)}
        </select></td>
      </tr>
    )
```
The `return` is JavaScript, but the rest in HTML. However, embedded in the HTML, surreounded by { and }, is more JavaScript, which in turn contains more HTML.

### Structure

Reach is component-based, with lower level components grouped inside higher components in a tree-like structure. At the top is App, which contains SidePane and MainPane. SidePane contains ObjectList (which handles putting objects in a tree structure), which contains TreeView (which actually shows the tree), which contains any number of TreeToggler components (which handles expending and collapsing components).

MainPane contains a number of TabComp cononents, one for each tab, each containing any number of InputComp components, which shows each component, which can be of type: text, textarea, flag, select, objects, number. Exactly what is displayed is set dynamically, using dictionaries called controls and tabs. An example of each (used during the early stages of development):

```
    this.controls = [
      { name:"name",   type:"text",     tab:0, default:"unnamed", display:"Name",
        tooltip:"The object's name; this is how it is identified in code. It can only contain letters, digits and underscores; it cannot start with a number.",
      },
      { name:"loc",    type:"objects",  tab:0, default:"---", display:"Location",
        tooltip:"Where the object is at the start of the game, the room or container. Should usually be blank for rooms (as they are not inside anything).",
      },
      { name:"gender", type:"select",   tab:0, default:"", display:"Gender",  options:["", "Male", "Female", "Other"],
        tooltip:"As it says.",
      },
      { name:"age",    type:"number",   tab:0, default:18, display:"Age",
        tooltip:"The object's age.",
      },
      { name:"happy",  type:"flag",     tab:0, default:true, display:"Happy?",
        tooltip:"Is the object happy?",
      },
      { name:"desc",   type:"textarea", tab:1, default:"", display:"Description",
        tooltip:"A description of the object.",
      },
    ];
    this.tabs = [
      { name:"Home", },
      { name:"Description", },
    ];
```
Note that the name field is hard-coded to only accept valid names (in `setValue` in App.js).

### React components

React components can be defined as a class or a function. Either way they have access to a variable `props`, a dictionary containing any values you explicitly sent when invoking the component. In this example:
```
<TreeView tree={tree} showObject={this.props.showObject}/>
```
... The `props` dictionary will contain "tree" and "showObject".

For a function, the `props` dictionary is sent as a parameter. Here is an example:

```
const TabComp = (props) => {
  const controls = props.controls.filter(el => el.tab == props.tab);  // double equals not triple!
  return (
    <div className="tabContent">
    <table><tbody>
    {controls.map((item, i) => 
    <InputComp display={item.display} name={item.name} value={props.object[item.name]} handleChange={props.handleChange} handleCBChange={props.handleCBChange} input={item} key={i} objects={props.objects} />
    )}
    </tbody></table>
    </div>
  )
}
```

For a class, `props` must be accessed via `this`. The format is like this:

```
export class TabComp extends React.Component {
  render() {
    const controls = this.props.controls.filter(el => el.tab == this.props.tab);  // double equals not triple!
    return (
      <div className="tabContent">
      <table><tbody>
      {controls.map((item, i) => 
      <InputComp display={item.display} name={item.name} value={this.props.object[item.name]} handleChange={this.props.handleChange} handleCBChange={this.props.handleCBChange} input={item} key={i} objects={this.props.objects} />
      )}
      </tbody></table>
      </div>
    )
  }
}
```

It is often convenient to pull out the values into local variables (third line below):

```
export class TabComp extends React.Component {
  render() {
    const {objects, object, handleChange, handleCBChange} = this.props;
    const controls = this.props.controls.filter(el => el.tab == this.props.tab);  // double equals not triple!
    return (
      <div className="tabContent">
      <table><tbody>
      {controls.map((item, i) => 
      <InputComp display={item.display} name={item.name} value={object[item.name]} handleChange={handleChange} handleCBChange={handleCBChange} input={item} key={i} objects={objects} />
      )}
      </tbody></table>
      </div>
    )
  }
}
```

State must be stored in the topmost component that uses it. In this case, nearly everything is stored in App, but the state of the tree (collapsed or expanded) is stored in each node. To allow that to happen, there is a constructor that sets the initial state, and a function that changes it. Note that this uses `setState` which prompts React to do its stuff.

The render method returns different values depending on the current state.

```
export class TreeToggler extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      expanded:true,
    }
  }
  
  toggler() {
    this.setState({
      expanded:!this.state.expanded,
    });
  }

  render() {
    const {tree, showObject} = this.props;
    if (this.state.expanded) {
      return (<li>
        <a onClick={this.toggler.bind(this)} className="caret">{String.fromCharCode(9660)}</a>
        <a onClick={() => showObject(this.props.tree.name)} className="treeItem">{tree.name}</a>
        <TreeView tree={tree.branch} showObject={showObject}/>
      </li>)
    }
    else {
      return (<li>
        <a onClick={this.toggler.bind(this)} className="caret">{String.fromCharCode(9654)}</a>
        <a onClick={() => showObject(this.props.tree.name)} className="treeItem">{tree.name}</a>
      </li>)
    }      
  }
}
```


The render method in `App` uses the `bind` method on its functions so `this` refers to `App`, wherever they are.

```
  render() {
    const currentObject = this.state.objects.find(el => el.name === this.state.currentObjectName);
    return (<div>
      <MainPane object={currentObject} handleChange={this.handleChange.bind(this)} removeObject={this.removeObject.bind(this)} handleCBChange={this.handleCBChange.bind(this)} controls={this.controls} tabs={this.tabs} objects={this.state.objects}/>
      <SidePane objects={this.state.objects} showObject={this.showObject.bind(this)} addObject={this.addObject.bind(this)}/>
    </div>);
  }
```